\chapter{Related Work}
\label{chapter:related_work}

\section{Directory Service}
Also known as name service, maps the names of network resources to their respective network addresses. Each resource on the network is considered an object by the directory server. Information about a particular resource is stored as a collection of attributes associated with that resource or object. One of the most representing example is the DNS, which offers internet domain names translation to ip addresses.

\section{DHT and P2P Networks}
A distributed hash table (DHT) is a class of a decentralised distributed system that provides a lookup service similar to a hash table: (key, value) pairs are stored in a DHT, and any participating node can efficiently retrieve the value associated with a given key

\subsection{DHT characteristics}
\begin{list}{}{}
\item \emph{Autonomy and decentralization}: multiple nodes, no central coordinator;
\item \emph{Fault tolerance}: reliable, no single point of failure (like Napster’s central server) (Byzantine fault tolerance);
\item \emph{Scalability}: the system scales. This means it’s working efficiently regardless the workload; 
\item \emph{Load balancing} (optional);
\item \emph{Data integrity} (optional).
\end{list}  

\subsection{Functioning Example}
Once these components are in place, a typical use of the DHT for storage and retrieval might proceed as follows. Suppose the keyspace is the set of 160-bit strings. To index a file with given filename and data in the DHT, the SHA-1 hash of filename is generated, producing a 160-bit key k, and a message put(k, data) is sent to any node participating in the DHT. The message is forwarded from node to node through the overlay network until it reaches the single node responsible for key k as specified by the keyspace partitioning. That node then stores the key and the data. Any other client can then retrieve the contents of the file by again hashing filename to produce k and asking any DHT node to find the data associated with k with a message get(k). The message will again be routed through the overlay to the node responsible for k, which will reply with the stored data.

\subsection{The Network}
Each node maintains a set of links to other nodes (its neighbors or routing table). Together, these links form the overlay network. A node picks its neighbors according to a certain structure, called the network's topology.

Aside from routing, there exist many algorithms that exploit the structure of the overlay network for sending a message to all nodes, or a subset of nodes, in a DHT. These algorithms are used by applications to do overlay multicast, range queries, or to collect statistic. (Flooding). 

\subsection*{Implementations Considered}
\begin{list}{}{}
\item Kademlia 
\item TomP2P
\end{list}

\section{Blockchain Implementations}
\subsection*{Bitcoin}
\subsection*{Namecoin}
\subsection*{Hyperledger}
\subsection*{Ehtereum}
\section{Blockstack Use Case}
\section{How to Store Social Records}
\subsection{Solution 1}
Store the Social Record directly in the data field of a transaction. 
Then the problems are: 

\begin{list}{}{}
\item How do I retrieve the social record?
\item Every time i update the social record, the transaction address changes
\item Storing an entire social record costs more gas than storing only its hash.
\item How should the social record be stored? Only one contract with all the Social Records inside? But then other problems arise like: the gas cost per each operation, the necessity to build a data structure inside the contract losing all the good properties provided by the blockchain. Then the data field space is only about 44KB.
\item If you use one transaction per Social Record, then you have to search through the entire blockchain, looking inside the transaction tree starting from the merkel root per each block. Not that efficient. 
\end{list}

\subsection{Solution 2}
This solution is inspired by Blockstack architecture and requires to create a DHT to map the GlobalID to the address of the transaction contained inside the blockchain. 

The transaction holds in the data field the hash of the Social Record. In this manner, the blockchain has the role of validation infrastructure rather than storage system. The actual data is stored in the distributed hash table. This solution could be vulnerable in case a malicious node tries to restore an old version of the social record by injecting the wrong address in the DHT table and causing a wrong mapping. 

Another vulnerability could be in the consistency of the data, some node could be inconsistent id the DHT doesn’t get updated. Therefore, the version control should be handled by the blockchain. Most of the vulnerabilities depend on the fact that a transaction stored in the blockchain has a different address every time we update the information contained within the Social Record. 

\subsection{Solution 3}
The third solution is based on the second one but requires each user to hold an Ethereum Wallet. In such design each transaction contains both the Wallet public key and the hash of the Social Record within the data field. Every time the Social Record gets updated, its hash changes and the new transaction will have a different address. 

The idea is to use the wallet public key as id, and map the GlobalID with the Wallet ID which will remain always the same. Searching inside the blockchain looking for the ID, the ledger will return the latest version. Compared to the second solution, the former provide version check through the blockchain rather than DHT. 

\section{Security}
\subsection{Elliptic Curves}
ECC is the next generation of public key cryptography, and based on currently understood mathematics, it provides a significantly more secure foundation than first-generation public key cryptography systems like RSA. 

With ECC, you can use smaller keys to get the same levels of security. Small keys are important, especially in a world where more and more cryptography is done on less powerful devices like mobile phones. While multiplying two prime numbers together is easier than factoring the product into its component parts, when the prime numbers start to get very long, even just the multiplication step can take some time on a low powered device. While you could likely continue to keep RSA secure by increasing the key length, that comes with a cost of slower cryptographic performance on the client. ECC appears to offer a better tradeoff: high security with short, fast keys.